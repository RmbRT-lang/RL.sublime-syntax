%YAML 1.2
---
# http://www.sublimetext.com/docs/3/syntax.html
name: RmbRT Language
file_extensions:
  - rl
  - rlh
  - rld
first_line_match: (\binclude\b.*|\(/(RL|rl)/\))
scope: source.rl
variables:
  ident: \b[a-zA-Z_][a-zA-Z0-9_]*\b
  lowercase_ident: \b[a-z_][a-zA-Z0-9_]*\b
  uppercase_ident: \b[A-Z][a-zA-Z0-9_]*\b
contexts:
  main:
    - match: \(/(RL|rl)/\)
      scope: constant.language.rl
    - include: comments
    - match: \b(INCLUDE)\b
      scope: keyword
      set:
        - match: (\")(.*)(\")
          captures:
            1: keyword.operator.rl
            3: keyword.operator.rl
            2: string.double.quote.rl
          set: main
        - match: (\')([^/]+)(/.*/)?(.*)(\')
          captures:
            1: keyword.operator.rl
            2: constant.numeric.rl
            3: keyword.rl
            4: string.single.quote.rl
            5: keyword.operator.rl
          set: main
        - match: (\')(.*)(\')
          captures:
            1: keyword.operator.rl
            3: keyword.operator.rl
            2: string.double.quote.rl
          set: main
    - match: (?=\S)
      set:
      - match: (?=\S)
        push: global
  global:
    - include: comments
    - include: test
    - include: namespace
    - include: enum
    - include: templatedecl
    - include: struct
    - include: rawtype
    - include: typedef
    - include: function-or-variable
    - include: external-symbol
    - include: union
    - include: concept
    - include: class
    - match: \S
      scope: invalid.illegal
  templatedecl:
    - match: \[
      scope: keyword.operator.rl
      set: [after_template_decl, templatedecl-inner-pre]
  member-templatedecl:
    - match: \[
      scope: keyword.operator.rl
      set: [after_member_template_decl, templatedecl-inner-pre]
  templatedecl-inner-pre:
    - match: \]
      scope: keyword.operator.rl
      pop: true
    - include: templatedecl-inner
  templatedecl-inner:
      - match: \b{{ident}}\b
        scope: string.template.rl
        set:
        - match: \.{3}
          scope: keyword.rl
          set: templatedecl-inner-after-name
        - include: templatedecl-inner-after-name
      - match: \S
        scope: invalid.illegal
  templatedecl-inner-after-name:
      - match: ':'
        scope: keyword.operator.rl
        set:
        - match: \b(TYPE|NUMBER)\b
          scope: keyword.control.rl
          set: templatedecl-close-or-comma
        - match: (?=\S)
          set: [templatedecl-close-or-comma, type-expression]
      - match: \S
        scope: invalid.illegal
  templatedecl-close-or-comma:
    - match: \;
      set: templatedecl-inner
    - match: \]
      scope: keyword.operator.rl
      pop: true
  after_template_decl:
    - include: typedef
    - include: concept
    - include: function-or-variable
    - include: class
    - include: rawtype
    - match: (?=\S)
      pop: true
  after_member_template_decl:
    - match: \[
      scope: invalid.illegal
    - include: class-member
    - match: (?=\S)
      pop: true
  type-identifier:
    - match: \b([A-Z][a-zA-Z0-9]+|[a-z_][a-z0-9_]*_t)\b
      scope: storage.type.name
      pop: true
    - match: \b[A-Z]\b
      pop: true
    - match: '{{ident}}(?=\s*::(?!=))'
      scope: meta.namespace.rl
      pop: true
    - match: '{{ident}}'
      scope: storage.type.name
      pop: true
  value-identifier:
    - match: '{{lowercase_ident}}(?=\s*::(?!=))'
      scope: meta.namespace.rl
      pop: true
    - match: '{{uppercase_ident}}(?=\s*::(?!=))'
      scope: storage.type.name.rl
      pop: true
    - match: '{{ident}}(?=\s*(\(|\bVISIT\b))'
      scope: meta.function-call.rl
      pop: true
    - match: '(?<=::){{lowercase_ident}}(?!\s*::(?!=))'
      scope: constant.other.variable.rl
      pop: true
    - match: '{{lowercase_ident}}(?=\s*::(?!=))'
      scope: variable.other.readwrite.member.rl
      pop: true
    - match: '\b([A-Z][a-zA-Z0-9]*)\b(?!::(?!=))'
      scope: variable.other.readwrite.member.rl
      pop: true
    - match: '\bs([A-Z0-9][a-zA-Z0-9]*|_[a-z0-9_]+)\b'
      scope: variable.other.readwrite.static.rl
      pop: true
    - match: '\bk([A-Z0-9][a-zA-Z0-9]*|_[a-z0-9_]+)\b'
      scope: constant.other.variable.rl
      pop: true
    - match: '\b[A-Z_][A-Z0-9_]+\b'
      scope: constant.numeric.rl
      pop: true
    - match: '{{ident}}'
      pop: true
  test:
    - match: \b(TEST)\b
      scope: keyword.rl
      set:
        - match: ("[^"]+")
          scope: string.quoted.double.rl
          set: blockstatement
  namespace:
    - match: (?=::)
      scope: keyword.control.rl
      set: namespace_name
  namespace_name:
    - meta_scope: entity.name.namespace.rl 
    - match: "::"
      scope: keyword
      push:
      - match: '{{ident}}'
        scope: meta.namespace.rl
        pop: true
    - match: (?=\s*(?!::))
      set: namespace_after_name
  namespace_after_name:
    - match: "{"
      scope: open.curly.bracket.block.rl
      set:
      - include: blockclose-no-semicolon
      - match: (?=\S)
        push: global
    - match: (?=\S)
      set: global
  enum:
    - match: \b(ENUM)\b
      scope: keyword.rl
      set:
      - match: '{{ident}}'
        scope: entity.name.type.rl storage.type.name.rl
        set:
        - match: \{
          scope: open.curly.bracket.block.rl
          set:
          - match: \}
            scope: close.curly.bracket.block.rl
            pop: true
          - include: enum-member-constant
  enum-member-constant:
    - include: comments
    - match: '{{ident}}'
      scope: entity.name.function.rl constant.numeric.rl
      set:
      - match: :=
        scope: keyword.operator.rl
        set: [enum-member-constant]
      - include: enum-member-after-constant
  enum-member-after-constant:
    - include: comments
    - match: \,
      set: enum-member-constant
    - match: \}
      scope: close.curly.bracket.block.rl
      pop: true
    - match: \S
      scope: invalid.illegal
  rawtype:
    - match: \(
      scope: keyword.operator.rl
      set: [rawtype-after-size, expression]
  rawtype-after-size:
    - match: \)
      scope: keyword.operator.rl
      set:
      - match: '{{ident}}'
        scope: entity.name.type.rl storage.type.name.rl
        set:
        - match: ";"
          scope: semi_colon.eol.ccpp
          pop: true
        - match: "{"
          scope: open.curly.bracket.block.rl
          set:
          - include: blockclose
          - match: (?=\S)
            push: rawtype-member
  rawtype-member:
    - match: \b(PUBLIC|PRIVATE)\b
      scope: keyword.rl
      set:
      - match: \b(PUBLIC|PRIVATE)\b
        scope: invalid.illegal
      - include: rawtype-member
    - match: \b(STATIC)\b
      scope: keyword.rl
      set:
      - include: templatedecl
      - include: function-or-variable
    - match: (?=\S)
      set:
      - include: templatedecl
      - include: typedef
      - include: function
  typedef:
    - match: \bTYPE\b
      scope: keyword.control.rl
      set:
      - match: '{{ident}}'
        scope: entity.name.type.rl storage.type.name.rl
        set:
        - match: :=
          scope: keyword.operator.rl
          set: [typedef-end, type-expression]
  typedef-end:
    - match: ";"
      scope: semi_colon.eol.ccpp
      pop: true
  union:
    - match: \b(UNION)\b
      scope: keyword.rl
      set:
        - match: '{{ident}}'
          scope: entity.name.type.rl storage.type.name.rl
          set: class-body
  concept:
    - match: \b(MASK)\b
      scope: keyword.rl
      set:
        - match: '{{ident}}'
          scope: entity.name.type.rl storage.type.name.rl
          set:
            - match: "{"
              scope: open.curly.bracket.block.rl
              set:
                - include: comments
                - match: "}"
                  scope: close.curly.bracket.block.rl
                  pop: true
                - match: (?=\S)
                  push: concept-member
  concept-member:
    - include: member-templatedecl
    - match: \b(PUBLIC|PRIVATE)\b
      scope: keyword.rl
      set:
      - match: \b(PUBLIC|PRIVATE)\b
        scope: invalid.illegal
      - include: concept-member
    - match: \b(STATIC)\b
      scope: keyword.rl
      set: function
    - match: (?=\S)
      set:
        - match: (#\s*\??)
          scope: keyword
          set: function
        - include: function
  class:
    - include: comments
    - match: '{{ident}}'
      scope: entity.name.type.rl storage.type.name.rl
      set:
      - include: class-after-name
      - match: \b(VIRTUAL)\b
        scope: keyword
        set: class-after-name
  class-after-name:
      - match: ->
        scope: keyword
        set: class-inheritance
      - include: class-body
  class-inheritance:
    - match: \b(VIRTUAL)\b
      scope: keyword
      set: class-inheritance-visibility
    - include: class-inheritance-visibility
  class-inheritance-visibility:
    - match: \b(PUBLIC|PRIVATE|PROTECTED)\b
      scope: keyword
      set: class-inheritance-symbol
    - include: class-inheritance-symbol
  class-inheritance-symbol:
    - match: (?=\S)
      set: [class-after-inheritance, type-expression-symbol]
  class-after-inheritance:
    - match: ","
      set: class-inheritance
    - match: (?=\S)
      set: class-body
  class-body:
    - match: "{"
      scope: open.curly.bracket.block.rl
      set:
      - include: blockclose-no-semicolon
      - include: comments
      - match: (?=\S)
        push: class-member
  class-meta:
    - meta_scope: meta.class.rl
    - match: ""
      pop: true
  class-member:
    - include: comments
    - match: \b(PUBLIC|PROTECTED|PRIVATE)\b\s*(:)
      captures:
        1: keyword
        2: keyword
      pop: true
    - match: \b(STATIC)\b|#\s*\??
      scope: keyword
      set:
        - match: \b(STATIC|\#\s*\??)\b
          scope: invalid.illegal
        - include: operator-overload
        - include: function-or-possibly-auto-variable
        - include: class-member
    - match: \b(PUBLIC|PROTECTED|PRIVATE)\b
      scope: keyword
      set: class-member-visible
    - include: class-member-visible
  operator-overload:
    - match: (\*|--?|\+\+?|~|!|&|\.\.[?!]|@@?|<-|##)
      scope: keyword.operator.rl
      set:
        - match: \b(THIS)\b
          scope: keyword
          set: [function-meta, function-after-head]
    - match: \<<<
      scope: keyword
      set: [function-meta, function-after-head, factory-arguments]
    - match: \<
      scope: keyword
      set: [function-meta, cast-operator-after-type, type-expression]
    - match: \b(THIS)\b
      scope: keyword
      set:
        - match: ((\.|->)\*|\+\+|--|!(?!=))
          scope: keyword.operator.rl
          set: [function-meta, function-after-head]
        - match: (\/|<<?<?=?|>>?>?=?|&[\&\=]?|\|[\|=]?|[-+*/%^]=?|[!:=]=|^)
          scope: keyword.operator.rl
          set: operator-after-name
        - include: operator-after-name
        - match: \[
          scope: keyword.operator.rl
          set: [function-meta, function-after-head, subscript-args]
        - match: \?
          scope: keyword.operator.rl
          set:
            - match: \(
              scope: meta.function-call.c
              set: [function-meta, cond-operator-colon, cond-operator-after-arg, function-arg]
  cast-operator-after-type:
    - match: \>
      scope: keyword
      set: function-after-head-cast
  cond-operator-colon:
    - match: ':'
      scope: keyword.operator.rl
      set:
        - match: \(
          scope: meta.function-call.c
          set: [function-after-head, cond-operator-after-arg, function-arg]
  cond-operator-after-arg:
    - match: \)
      scope: meta.function-call.c
      pop: true
  operator-after-name:
    - match: \(
      scope: meta.function-call.c
      set: [function-meta, function-after-head, function-arguments]
  subscript-args:
    - match: \]
      scope: keyword.operator.rl
      pop: true
    - match: (?=\S)
      set: [subscript-after-arg, function-arg]
  subscript-after-arg:
    - include: comments
    - match: \]
      scope: keyword.operator.rl
      pop: true
    - match: \,
      push: function-arg
    - match: \S
      scope: invalid.illegal
  class-member-visible:
    - match: \b(STATIC)\b|#\s*\??
      scope: keyword
      set:
        - match: \b(STATIC)\b|\#\s*\??
          scope: invalid.illegal
        - include: operator-overload
        - include: function-or-possibly-auto-variable
        - include: class-member-visible
    - match: \b(VIRTUAL|ABSTRACT|OVERRIDE|FINAL)\b
      scope: keyword
      set:
        - include: member-function-or-variable
        - include: operator-overload
    - include: comments
    - include: enum
    - include: union
    - include: typedef
    - include: member-templatedecl
    - include: constructor
    - include: destructor
    - include: operator-overload
    - include: member-function-or-variable
    - include: class
  destructor:
    - match: \b(DESTRUCTOR)\b
      scope: keyword.rl
      set:
      - match: \b(INLINE)\b
        scope: keyword.rl
        set:
          - include: blockstatement
          - include: semicolon-close-noerr
      - include: blockstatement
      - include: semicolon-close-noerr
  symbol-constant:
    - match: (:(?!:))
      scope: string.symbolic.rl
      set:
        - match: \s+
          scope: invalid.illegal
        - match: (<[->]|[<>?!])
          scope: string.symbolic.rl
          pop: true
        - match: '{{ident}}'
          scope: string.symbolic.rl
          pop: true
        - match: \S+
          scope: invalid.illegal
  constructor:
    - include: constructor-open
    - match: (?=:)
      set: [constructor-open, symbol-constant]
  constructor-open:
    - match: \{
      scope: meta.function-call.c
      set: [constructor-member, constructor-arguments]
  constructor-arguments:
    - include: comments
    - match: (#\s*&|&&)
      scope: keyword
      set:
        - match: '{{ident}}'
          scope: constant.numeric.rl
          set:
            - match: \}
              scope: meta.function-call.c
              pop: true
        - match: \}
          scope: meta.function-call.c
          pop: true
    - match: \}
      scope: meta.function-call.c
      pop: true
    - match: (?=\S)
      set: [constructor-after-arg, function-arg]
  constructor-after-arg:
    - include: comments
    - match: \}
      scope: meta.function-call.c
      pop: true
    - match: \,
      push: function-arg
    - match: \S
      scope: invalid.illegal
  constructor-member:
    - match: \b(INLINE)\b
      scope: keyword.rl
      set:
      - match: \b(INLINE)\b
        scope: invalid.illegal
      - include: constructor-member
    - match: '->'
      scope: keyword
      set: constructor-base-init
    - match: ':'
      scope: meta.function-call.rl
      set: constructor-member-init
    - include: blockstatement
    - match: \;
      scope: semi_colon.eol.ccpp
      pop: true
  constructor-base-init:
    - match: (?=\S)
      set: [constructor-base-init-after, constructor-init-after-name]
  constructor-member-init:
    - match: '{{ident}}(?=\s*\()'
      scope: variable.other.readwrite.member.c++
      set: [constructor-member-init-after, constructor-init-after-name]
  constructor-init-after-name:
    - match: \(
      scope: meta.function-call.rl
      set:
      - match: \b(NOINIT)\b
        scope: keyword.rl
        set:
        - match: \)
          scope: meta.function-call.rl
          pop: true
      - match: (?=\S)
        set: arg-or-close
  constructor-base-init-after:
    - include: blockstatement
    - match: \,
      set: constructor-base-init
    - match: ;
      scope: semi_colon.eol.ccpp
      pop: true
    - match: ':'
      scope: meta.function-call.rl
      set: constructor-member-init
    - match: \S+
      scope: invalid.illegal.rl
      pop: true
  constructor-member-init-after:
    - include: blockstatement
    - match: \,
      set: constructor-member-init
    - match: ;
      scope: semi_colon.eol.ccpp
      pop: true
    - match: \S+
      scope: invalid.illegal.rl
      pop: true
  external-symbol:
    - match: \b(EXTERN)\b
      scope: keyword.rl
      set:
      - match: \[
        set: [external-symbol-after-string, string]
      - match: (?=\S)
        set: external-symbol-name
  external-symbol-after-string:
    - match: \]
      set: external-symbol-name
  external-symbol-name:
    - match: '{{ident}}'
      scope: entity.name.function.rl
      set:
      - match: ':'
        set: [semicolon-close, type-expression] 
      - match: '\('
        scope: meta.function-call.c
        set: [semicolon-close, type-expression, function-arguments]
  struct:
    - match: \bstruct\b
      scope: keyword.control.rl
      push:
      - match: '{{ident}}'
        scope: storage.type.name.rl
        set:
        - match: :=
          scope: keyword.operator.rl
          set:
          - match: "{"
            scope: keyword.operator.rl
            set:
            - include: blockclose
  function-or-variable:
    - match: '({{ident}})\s*(\()'
      captures:
        1: entity.name.function.rl
        2: meta.function-call.c
      set: [function-meta, function-after-head, function-arguments]
    - match: '({{ident}})\s*(:)(?![:=])'
      captures:
        1: constant.numeric.rl
      set: [semicolon-close, variable-initialiser, type-expression]
  member-function-or-variable:
    - match: '({{ident}})\s*(\()'
      captures:
        1: entity.name.function.rl
        2: meta.function-call.c
      set: [function-meta, function-after-head, function-arguments]
    - match: '({{ident}})\s*(:)(?![:=])'
      captures:
        1: variable.other.readwrite.member.rl
      set: [semicolon-close, variable-initialiser, type-expression]
    - match: (?={{ident}}\s*(::|;|\#|\$|\*|&|\\))
      set: [semicolon-close, type-expression]
  function-or-possibly-auto-variable:
    - include: function-or-variable
    - match: ({{ident}})(?=\s*([#$]|::=))
      captures:
        1: constant.numeric.rl
      set: [auto-variable, value-identifier]
  auto-variable:
    - match: (\#)\s*(\$)?|(\$)\s*(\#)?
      captures:
        1: keyword.rl
        2: keyword.rl
        3: keyword.rl
        4: keyword.rl
      set:
        - match: \.
          scope: keyword.rl
          set: auto-variable-init
        - include: auto-variable-init
    - match: \.
      scope: keyword.rl
      set: auto-variable-init
    - include: auto-variable-init
  auto-variable-init:
    - match: ::=
      scope: keyword.operator.rl
      set: expression-stmt    
  function:
    - match: '\b({{ident}})\b\s*(\()'
      captures:
        1: entity.name.function.rl
        2: meta.function-call.c
      set: [function-meta, function-after-head, function-arguments]
  function-meta:
    - meta_scope: meta.function.rl
    - match: ""
      pop: true
  factory-arguments:
    - include: comments
    - match: \>\>\>
      scope: keyword
      pop: true
    - match: (?=\S)
      set: [factory-after-arg, function-arg]
  factory-after-arg:
    - include: comments
    - match: \>\>\>
      scope: keyword
      pop: true
    - match: \,
      push: function-arg
    - match: \S
      scope: invlaid.illegal
  function-arguments:
    - include: comments
    - match: \)
      scope: meta.function-call.c
      pop: true
    - match: (?=\S)
      set: [function-after-arg, function-arg]
  function-after-arg:
    - include: comments
    - match: \)
      scope: meta.function-call.c
      pop: true
    - match: \,
      push: function-arg
    - match: \S
      scope: invalid.illegal
  function-arg:
    - include: comments
    - match: '({{ident}})\s*:(?!:)'
      captures:
        1: constant.numeric.rl
      set: [function-arg-default-init, type-expression]
    - match: (?=\[|{{ident}}|:(?!:)|\{)
      set: [function-arg-default-init, type-expression]
  function-arg-default-init:
    - include: comments
    - match: :=
      scope: keyword.operator.rl
      set: expression
    - match: \(
      set:
      - include: comments
      - match: \)
        pop: true
      - match: (?=\S)
        set: [function-arg-default-init-after-arg, expression]
    - match: (?=\S)
      pop: true
  function-arg-default-init-after-arg:
    - include: comments
    - match: \)
      pop: true
    - match: \,
      push: expression
    - match: \S
      scope: invalid.illegal
  function-after-head:
    - match: \@
      scope: keyword.rl
      set:
      - match: \@
        scope: invalid.illegal
      - include: function-after-head
    - match: \#\s*\??\s*\$?|\$\s*(\#\s*\??)?
      scope: keyword
    - match: \&\&?
      scope: storage.modifier.rl
    - match: '::='
      scope: keyword.operator.rl
      set:
      - include: comments
      - include: expression-stmt
    - match: \b(INLINE)\b
      scope: keyword.rl
      set:
      - match: \#\s*\??\s*\$?|\$\s*(\#\s*\??)?
        scope: keyword
      - match: \&\&?
        scope: storage.modifier.rl
      - match: '::='
        scope: keyword.operator.rl
        set: expression-stmt
      - match: \?
        scope: keyword
        set: blockstatement
      - match: (?=\S)
        set: [function-5, type-expression]
      - match: \S
        scope: invalid.illegal
    - match: \?
      scope: keyword
      set: blockstatement
    - match: (?=\S)
      set: [function-5, type-expression]
    - match: \S
      scope: invalid.illegal
  function-after-head-cast:
    - match: \@
      scope: keyword.rl
      set:
      - match: \@
        scope: invalid.illegal
      - include: function-after-head
    - match: ':='
      scope: keyword.operator.rl
      set:
      - match: \b(INLINE)\b
        scope: keyword.rl
        set:
        - include: comments
        - include: expression-stmt
        - match: \S
          scope: invalid.illegal
      - include: comments
      - include: expression-stmt
    - match: \b(INLINE)\b
      scope: keyword.rl
      set:
      - match: ':='
        scope: keyword.operator.rl
        set: expression-stmt
      - include: blockstatement
      - match: (?=\S)
        set: [function-5, type-expression]
      - match: \S
        scope: invalid.illegal
    - include: blockstatement
    - match: (?=\S)
      set: [function-5, type-expression]
    - match: \S
      scope: invalid.illegal
  function-5:
    - meta_scope: meta.function.rl
    - include: comments
    - include: semicolon-close
    - match: (&|&&)
      scope: storage.modifier.rl
      set:
        - match: ;
          scope: semi_colon.eol.ccpp
          pop: true
        - match: :=
          scope: keyword.operator.rl
          set: [semicolon-close, expression]
        - include: blockstatement
    - match: :=
      scope: keyword.operator.rl
      set: [semicolon-close, expression]
    - include: blockstatement
  semicolon-close:
    - include: comments
    - match: ;
      scope: semi_colon.eol.ccpp
      pop: true
    - match: \s*[\r|\n]*$
      scope: invalid.illegal
  semicolon-close-noerr:
    - include: comments
    - match: ;
      scope: semi_colon.eol.ccpp
      pop: true
  blockclose:
    - include: comments
    - match: "}"
      scope: close.curly.bracket.block.rl
      pop: true
  blockclose-no-semicolon:
    - include: comments
    - match: "}"
      scope: close.curly.bracket.block.rl
      pop: true
  static-variable-stmt:
    - include: comments
    - match: \b(STATIC)\b
      scope: keyword.rl
      set: [semicolon-close, variable]
  variable-or-expression-stmt:
    - include: comments
    - match: '({{ident}})\s*(::=)'
      captures:
        1: constant.numeric.rl
        2: keyword.operator.rl
      set: [semicolon-close, expression]
    - match: '({{ident}})\s*(:)(?![:=])'
      captures:
        1: constant.numeric.rl
      set:
        - match: \?
          scope: keyword
          set: [semicolon-close, variable-initialiser, type-qualifier]
        - match: (?=\S)
          set: [semicolon-close, variable-initialiser, type-expression]
    - match: '{{ident}}(?=\s*(#|\$|::=))'
      scope: constant.numeric.rl
      set: [auto-variable]
    - match: (?=\S)
      set: expression-stmt
  variable-or-expression-stmt-or-empty:
    - include: semicolon-close
    - include: variable-or-expression-stmt
  variable-or-expression:
    - include: comments
    - match: '({{ident}})\s*(::=)'
      captures:
        1: constant.numeric.rl
        2: keyword.operator.rl
      set: expression
    - match: '{{ident}}\s*(:)(?![:=])'
      captures:
        1: keyword.operator.rl
      set: [variable-initialiser, type-expression]
    - match: '{{ident}}\s*(?=#|\$|::=)'
      set:
      - match: (#\s*\??)
        scope: keyword
        set:
        - match: (\$)
          scope: keyword
          set: variable-short-initialiser
        - include: variable-short-initialiser
      - match: (\$)
        scope: keyword
        set:
        - match: (#\s*\??)
          scope: keyword
          set: variable-short-initialiser
        - include: variable-short-initialiser
    - match: (?=\S)
      set: expression
  variable-short-initialiser:
    - match: ::=
      scope: keyword.operator.rl
      set: expression
    - match: \S
      scope: invalid.illegal
  variable:
    - include: comments
    - match: '{{ident}}'
      scope: constant.numeric.rl
      set: variable-expect-colon
  variable-expect-colon:
    - include: comments
    - match: '::='
      scope: keyword.operator.rl
      set: expression
    - match: ':'
      scope: keyword.operator.rl
      set: [variable-initialiser, type-expression]
  variable-initialiser:
    - include: comments
    - match: ':='
      scope: keyword.operator.rl
      set:
      - match: \b(NOINIT)\b
        scope: keyword
        pop: true
      - include: expression
    - match: \(
      scope: meta.function-call.rl
      set: [arg-or-close]
    - match: (?=\S)
      pop: true
  arg-or-close:
    - include: comments
    - match: \)
      scope: meta.function-call.rl
      pop: true
    - match: \b(NOINIT)\b
      scope: keyword.rl
      set:
      - match: \)
        scope: meta.function-call.rl
        pop: true
    - match: (?=\S)
      set: [constructor-call, expression]
  constructor-call:
    - match: ','
      push: expression
    - match: \)
      scope: meta.function-call.rl
      pop: true
  arg-comma-or-close:
    - match: ','
  type-expression:
    - include: comments
    - match: \b(TYPE)\b
      scope: keyword.rl
      set:
      - match: \(
        set: [type-qualifier, parenthese-close-pop, expression]
    - match: \{
      scope: keyword
      set: [tuple-type-after-first, type-expression]
    - match: \b(VOID|U?(INT|CHAR)|BOOL|[US][1248]|SINGLE|DOUBLE)\b
      scope: keyword.rl
      set: type-qualifier
    - include: fn-signature
    - match: (?={{ident}}|\[|::(?!=))
      set: type-expression-symbol
    - match: :\.
      scope: keyword.constant.rl
      set: type-qualifier
    - match: (?=:(?!:))
      set: [type-qualifier, symbol-constant]
  tuple-type-after-first:
    - match: \,
      set: [tuple-type-after-n, type-expression]
  tuple-type-after-n:
    - match: \}
      scope: keyword
      set: type-qualifier
    - include: tuple-type-after-first
  fn-signature:
    - match: \(
      scope: meta.function-call.rl
      set:
      - include: comments
      - match: \(
        set:
        - match: \)
          set:
          - match: \@|\&
            scope: keyword.rl
            set: [fn-signature-end, type-expression]
          - match: (?=\S)
            set: [fn-signature-end, type-expression]
        - match: (?=\S)
          set: [fn-signature-after-arg, type-expression]
      - match: \S
        scope: invalid
  type-expression-symbol:
    - include: comments
    - include: type-expression-symbol-root
    - match: (::)(?!=)
      scope: meta.namespace.rl
      set: type-expression-symbol-root
  type-expression-symbol-root:
    - match: '{{lowercase_ident}}(?=::)'
      scope: meta.namespace.rl
      set: type-expression-after-name
    - match: '{{uppercase_ident}}(?=::)'
      scope: storage.type.name.rl
      set: type-expression-after-name
    - match: '{{ident}}(?!::)'
      scope: storage.type.name.rl
      set: type-expression-after-name
    - match: \[
      scope: meta.function-call.c
      set:
      - include: comments
      - match: \]
        scope: meta.function-call.c
        set: [type-expression-after-name, type-identifier]
      - match: \#
        scope: constant.numeric.rl
        set: [type-expression-template-comma-or-bracketclose, expression-list-commas-after-expression, expression]
      - match: \;
        scope: keyword
        set: type-expression-template-comma-or-bracketclose
      - match: (?=\S)
        set: [type-expression-template-comma-or-bracketclose, type-list-commas-after-type, type-expression]
  expression-symbol:
    - include: comments
    - match: (?={{ident}})
      set: [expression-after-name, value-identifier]
    - match: \[
      scope: meta.function-call.c
      set:
      - include: comments
      - match: \]
        scope: meta.function-call.c
        set: [expression-after-name, value-identifier]
      - match: \#
        scope: constant.numeric.rl
        set: [expression-template-comma-or-bracketclose, expression-list-commas-after-expression, expression]
      - match: \;
        scope: keyword
        set: expression-template-comma-or-bracketclose
      - match: (?=\S)
        set: [expression-template-comma-or-bracketclose, type-list-commas-after-type, type-expression]
  expression-symbol-child:
    - include: comments
    - match: (?={{ident}})
      set: value-identifier
    - match: (?=\[)
      set: [value-identifier, template-arguments]
  template-arguments:
    - include: comments
    - match: \[
      scope: meta.function-call.c
      set:
      - include: comments
      - match: \]
        scope: meta.function-call.c
        pop: true
      - include: tpl-arg
  tpl-arg:
    - include: comments
    - match: \#
      scope: constant.numeric.rl
      set: [after-tpl-arg, expression]
    - match: (?=\S)
      set: [after-tpl-arg, type-expression]
  after-tpl-arg:
    - include: comments
    - match: \,
      set: tpl-arg
    - match: \]
      scope: meta.function-call.c
      pop: true
  type-expression-template-comma-or-bracketclose:
    - include: comments
    - match: \;
      scope: keyword
      set:
      - include: comments
      - match: \]
        scope: invalid.illegal
      - match: \#
        scope: constant.numeric.rl
        set: [type-expression-template-comma-or-bracketclose, expression-list-commas-after-expression, expression]
      - match: \;
        scope: keyword
        set: type-expression-template-comma-or-bracketclose
      - match: (?=\S)
        set: [type-expression-template-comma-or-bracketclose, type-list-commas-after-type, type-expression]
    - match: \]
      scope: meta.function-call.c
      set: [type-expression-after-name, type-identifier]
    - match: \S+
      scope: invalid.illegal
      pop: true
  expression-list-commas-after-expression:
    - include: comments
    - match: \,
      set: [expression-list-commas-after-expression, expression]
    - match: (?=\S)
      pop: true
  type-list-commas-after-type:
    - include: comments
    - match: \,
      set: [type-list-commas-after-type, type-expression]
    - match: (?=\S)
      pop: true
  expression-template-comma-or-bracketclose:
    - include: comments
    - match: \;
      scope: keyword
      set:
      - include: comments
      - match: \]
        scope: invalid.illegal
      - match: \#
        scope: constant.numeric.rl
        set: [type-expression-template-comma-or-bracketclose, expression-list-commas-after-expression, expression]
      - match: \;
        scope: keyword
        set: type-expression-template-comma-or-bracketclose
      - match: (?=\S)
        set: [type-expression-template-comma-or-bracketclose, type-list-commas-after-type, type-expression]
    - match: \]
      scope: meta.function-call.c
      set: [expression-after-name, value-identifier]
    - match: \S+
      scope: invalid.illegal
      pop: true
  type-expression-after-name:
    - include: comments
    - match: '::'
      scope: meta.function-call.rl
      set: type-expression-symbol
    - include: type-qualifier
  expression-after-name:
    - include: comments
    - match: '::'
      scope: meta.function-call.rl
      set: expression-symbol
    - match: (?=\S)
      pop: true
  fn-signature-after-arg:
    - include: comments
    - match: \,
      push: type-expression
    - match: \)
      set:
      - match: \@|\&
        scope: keyword.rl
        set: [fn-signature-end,  type-expression]
      - match: (?=\S)
        set: [fn-signature-end, type-expression]
    - match: \S
      scope: invalid.illegal
  fn-signature-end:
    - match: \)
      scope: meta.function-call.rl
      set: type-qualifier-step-indirection
    - match: \S
      scope: invalid.illegal
  type-qualifier:
    - include: comments
    - include: type-qualifier-step-nodecay
  type-qualifier-step-nodecay:
    - match: \!
      scope: keyword.rl
      set: type-qualifier-step-qualifier
    - include: type-qualifier-step-qualifier
  type-qualifier-step-qualifier:
    - match: \#\s*\??
      scope: storage.modifier.qualifier.rl
      set:
        - match: \$
          scope: storage.modifier.qualifier.rl
          set: type-qualifier-step-atomic
        - include: type-qualifier-step-atomic
    - match: \$
      scope: storage.modifier.qualifier.rl
      set:
        - match: \#\s*\??
          scope: storage.modifier.qualifier.rl
          set: type-qualifier-step-atomic
        - include: type-qualifier-step-atomic
    - include: type-qualifier-step-atomic
  type-qualifier-step-atomic:
    - match: \.
      scope: keyword.rl
      set:
        - match: \.
          scope: invalid.illegal.rl
        - match: (?=\S)
          set: type-qualifier-step-indirection
    - include: type-qualifier-step-indirection
  type-qualifier-step-indirection:
    - match: ([*\\@^]|\.{2}[!?])
      scope: storage.modifier.indirection.rl
      set: type-qualifier
    - match: \[
      set:
        - include: type-qualifier-array-close
        - match: (?=\S)
          set: [type-qualifier-array-after-dimension, expression]
    - include: type-reference
  type-qualifier-array-after-dimension:
    - match: \,
      set: [type-qualifier-array-after-dimension, expression]
    - include: type-qualifier-array-close
  type-qualifier-array-close:
    - match: \]
      set: type-qualifier-step-indirection
  type-reference:
    - match: (&&?)
      scope: storage.modifier.rl
      set: type-variadic-expand
    - include: type-variadic-expand
  type-variadic-expand:
    - match: \.{3}
      scope: keyword.rl
      pop: true
    - include: type-infix-template
  type-infix-template:
    - match: (\-)
      scope: constant.numeric.rl
      set: type-expression-symbol
    - match: (?=\S)
      pop: true
  expression-or-ambiguous-statement-expression:
    - include: ambiguous-statement-expression
    - include: expression
  expression:
    - include: comments
    - include: string
    - include: char
    - include: unambiguous-statement-expression
    - match: \b(TRUE|FALSE|NULL)\b
      scope: constant.language.rl
      set: expression-after-operand
    - match: \b(TYPE)\b
      scope: keyword
      set:
        - match: \b(TYPE)\b
          scope: keyword
          set:
            - match: \(
              set: [expression-pop-parenthese, type-expression]
        - match: \b(STATIC)\b
          scope: keyword
          set:
            - match: \(
              set: [expression-pop-parenthese, expression]
        - match: \(
          set: [expression-pop-parenthese, expression]
        - match: \S
          scope: invalid.illegal
    - match: \b(SIZEOF)(...)?\b
      scope: keyword.rl
      set:
        - match: \(
          set:
            - match: \#
              scope: constant.numeric.rl
              set: [expression-pop-parenthese, expression]
            - match: (?=\S)
              set: [expression-pop-parenthese, type-expression]
    - match: \.{2}[!?]
      scope: keyword.rl
      set:
        - match: \.{2}[!?]
          scope: invalid.illegal
        - include: expression
    - match: \@@?|\^
      scope: keyword.control.rl
      set:
        - match: \@@?|\^
          scope: invalid.illegal
        - match: \.{2}[!?]
          scope: invalid.illegal
        - include: expression
    - match: (\+[\+:]?|-[-:]?|~:?|!:?|\*|<-|&|\\|##)
      scope: keyword.operator.rl
      set: expression
    - match: (\#\s*\??)\s*(\$)?|(\$)\s*(#\s*\??)?
      captures:
        1: keyword.rl
        2: keyword.rl
        3: keyword.rl
        4: keyword.rl
    - match: \(
      set: [expression-tuple-after-value, expression-or-ambiguous-statement-expression]
    - match: (?=\[)
      set: [expression-after-operand, expression-symbol]
    - match: \<<<
      scope: keyword.rl
      set: [expression-close-concept-cast-bracket, type-expression]
    - match: \<\<
      scope: keyword.rl
      set: [expression-close-dynamic-cast-bracket, type-expression]
    - match: \<
      scope: keyword.rl
      set: [expression-close-cast-bracket, type-expression]
    - match: \b(0([xX][0-9a-fA-F]+\.[0-9a-fA-F]*|[0-7]+\.[0-7]*)|(0|[1-9][0-9]*)\.[0-9]*)(['_][hsdqHSDQ])?\b
      scope: constant.numeric.rl
      set: expression-after-operand
    - match: \b(0([xX][0-9a-fA-F]+|[0-7]+)|0|[1-9][0-9]*)\b
      scope: constant.numeric.rl
      set: expression-after-operand
    - match: \b(THIS)\b
      scope: variable.language.rl keyword.rl
      set: expression-after-operand
    - match: (::)
      scope: meta.namespace.rl
      set: [expression-after-operand, expression-symbol]
    - match: (?={{ident}})
      set: [expression-after-operand, expression-symbol]
    - match: (:(?!:))
      scope: string.symbolic.rl
      set:
        - match: \s+
          scope: invalid.illegal
        - match: (<[->]|[<>!?])
          scope: string.symbolic.rl
          set: expression-after-operand
        - match: '{{ident}}'
          scope: string.symbolic.rl
          set: expression-after-operand
    - match: \S
      scope: invalid.illegal
  expression-tuple-after-value:
    - match: \,
      push: expression
    - include: expression-pop-parenthese
  expression-close-dynamic-cast-bracket:
    - match: \>\>
      scope: keyword.rl
      set:
        - match: \(
          scope: keyword.rl
          set: [expression-close-dynamic-cast-parenthese, expression]
  expression-close-dynamic-cast-parenthese:
    - match: \)
      scope: keyword.rl
      set: expression-after-operand
  expression-close-cast-bracket:
    - match: \>
      scope: keyword.rl
      set:
        - match: \(
          scope: keyword.rl
          set:
            - match: \)
              scope: keyword.rl
              set: expression-after-operand
            - match: (?=\S)
              set: [expression-close-cast-parenthese, expression]
  expression-close-concept-cast-bracket:
    - match: \>>>
      scope: keyword.rl
      set:
        - match: \(
          scope: keyword.rl
          set: [expression-close-cast-parenthese, expression]
  expression-close-cast-parenthese:
    - match: \,
      push: expression
    - match: \)
      scope: keyword.rl
      set: expression-after-operand
  string-common:
    - match: \\[nrtefvba0\\]
      scope: constant.character.escape.rl
    - match: \\[xX][0-9a-fA-F]{2}
      scope: constant.character.escape.rl
    - match: \\[oO][0-3][0-7]{2}
      scope: constant.character.escape.rl
    - match: \\[dD]([0-1]\d\d|2[0-4]\d|25[0-5])
      scope: constant.character.escape.rl
    - match: \\[oOdD]...
      scope: invalid.illegal
  string:
    - match: (8|(16|32)[lLbB]?)?\"
      captures:
        0: punctuation.definition.string.begin.rl
      set:
        - meta_scope: string.quoted.double.rl
        - include: string-common
        - match: \\\"
          scope: constant.character.escape.rl
        - match: \"
          captures:
            0: punctuation.definition.string.end.rl
          set:
            - include: string
            - match: (?=\S)
              set: expression-after-operand
  char:
    - match: (8|(16|32)[lLbB]?)?\'
      captures:
        0: punctuation.definition.string.begin.rl
      set:
        - meta_scope: string.quoted.single.rl
        - include: string-common
        - match: \\\'
          scope: constant.character.escape.rl
        - match: \'
          captures:
            0: punctuation.definition.string.end.rl
          set: expression-after-operand
  expression-after-operand:
    - match: \.{3}
      scope: keyword
    - match: ([\.]|->)\*
      scope: keyword.operator.rl
      set: expression
    - match: \b(VISIT)\b
      scope: keyword.rl
      set:
        - match: \(
          scope: meta.function-call.c
          set:
            - match: \)
              scope: invalid.illegal
              set: expression-after-operand
            - match: (?=\S)
              set: [call-arguments, expression]
    - match: ([\.]|->)
      scope: period.ccpp
      set:
      - match: \~
        scope: keyword.rl
        set: expression-after-operand
      - match: \{
        scope: keyword.rl
        set:
          - match: \}
            scope: keyword.rl
            set: expression-after-operand
          - match: (?=\S)
            set: [ctor-call-after-arg, expression]
      - match: (?=\[)
        set: [expression-after-operand, expression-symbol-child]
      - match: \(
        scope: keyword period.ccpp
        set:
          - match: \d+
            scope: variable.other.readwrite.member.rl
            set:
              - match: \)
                scope: keyword period.ccpp
                set: expression-after-operand
      - match: \b([a-zA-Z_][a-zA-Z0-9_]*)\b(?!\s*(\(|\bVISIT\b))
        scope: variable.other.readwrite.member.rl
        set: expression-after-operand
      - match: \b([a-zA-Z_][a-zA-Z0-9_]*)\b(?=\s*(\(|\bVISIT\b))
        scope: meta.function-call.c
        set: expression-after-operand
      - match: \S
        scope: invalid.illegal
    - match: \@@?
      scope: keyword.control.rl
      set: expression-post-operator
    - include: comments
    - include: expression-post-operator
  ctor-call-after-arg:
    - match: \,
      push: expression
    - match: \}
      scope: keyword.rl
      set: expression-after-operand
  expression-post-operator:
    - match: (\+\+|--)
      scope: keyword.operator.rl
    - match: (<<<?=?|>>>?=?|\|\||&&|[-^+*/&%|<>]=?|[!:=]=)
      scope: keyword.operator.rl
      set: expression
    - match: \!
      scope: keyword.rl
      set: expression-after-operand
    - match: \(
      scope: meta.function-call.c
      set: 
      - match: \)
        scope: meta.function-call.c
        set: expression-after-operand
      - match: (?=\S)
        set: [call-arguments, expression]
    - match: \[
      set: [expression-pop-bracket, expression]
    - match: \?
      scope: keyword.control.rl
      set: [expression-ternary-colon, expression]
    - match: (?=\S)
      pop: true
  call-arguments:
    - match: \)
      scope: meta.function-call.c
      set: expression-after-operand
    - match: \,
      push: expression
  expression-ternary-colon:
    - include: comments
    - match: ':'
      scope: keyword.control.rl
      set: expression
    - match: \S
      scope: invalid.illegal
  expression-pop-parenthese:
    - include: comments
    - match: \)
      set: expression-after-operand
    - match: (?=\S)
      scope: invalid.illegal
  expression-pop-bracket:
    - include: comments
    - match: \]
      set: expression-after-operand
    - match: (?=\S)
      scope: invalid.illegal
  statement:
    - include: comments
    - include: blockstatement
    - include: wait-or-sleep
    - include: if
    - include: throw
    - include: type-switch
    - include: switch
    - include: while
    - include: do-loop
    - include: break
    - include: continue
    - include: for
    - include: return
    - include: try
    - include: assert
    - include: static-variable-stmt
    - include: variable-or-expression-stmt
    - match: \S
      scope: invalid.illegal
  unambiguous-statement-expression:
      - include: comments
      - include: blockstatement
      - include: type-switch
      - include: switch
      - include: do-loop
  ambiguous-statement-expression:
      - include: comments
      - include: if
      - include: while
      - include: for
      - include: try
  blockstatement:
    - match: '{'
      scope: open.curly.bracket.block.rl
      set:
      - include: comments
      - match: ;
        scope: semi_colon.eol.ccpp
        set:
        - match: \}
          scope: close.curly.bracket.block.rl
          pop: true
        - match: \S
          scope: invalid.illegal.rl
      - match: \}
        scope: close.curly.bracket.block.rl
        pop: true
      - match: (?=\S)
        push: statement
  wait-or-sleep:
    - match: \.{3}
      scope: keyword
      set:
        - include: semicolon-close
        - match: (?=\S)
          set: [semicolon-close, expression]
  expression-stmt:
    - match: (?=\S)
      set: [semicolon-close, expression]
  throw:
    - match: \b(THROW)\b\s*(\.\.\.)?\s*(;)
      captures:
        1: keyword.rl
        2: keyword.operator.rl
        3: semi_colon.eol.ccpp
      pop: true
    - match: \b(THROW)\b
      scope: keyword.rl
      set: expression-stmt
  if:
    - match: \b(IF)\b
      scope: keyword.control.rl
      set: [if-condition, control-label]
  if-condition:
      - include: comments
      - match: \(
        set: [if-after-condition, variable-or-expression]
  if-after-condition:
    - match: \)
      set: [if-after-statement, statement]
  if-after-statement:
    - include: comments
    - match: \b(ELSE)\b
      scope: keyword.control.rl
      set: [statement, control-label]
    - match: (?=\S)
      pop: true
  type-switch:
    - match: \b(TYPE\s+SWITCH)\b
      scope: keyword.control.rl
      set:
        - match: \b(STATIC)\b
          scope: keyword
          set: type-switch-value
        - include: type-switch-value
  type-switch-value:
    - match: \(
      set: [type-switch-after-value, expression]
  type-switch-after-value:
    - match: \)
      set:
        - match: \{
          scope: open.curly.bracket.block.rl
          set: type-case
  type-case:
    - match: \b(DEFAULT)\b
      scope: keyword.control.rl
      set: type-case-after-value
    - match: (?=\S)
      set: [type-case-after-value, type-expression]
  type-case-after-value:
    - match: \,
      push: type-expression
    - match: ':'
      set: [after-type-case, statement]
  after-type-case:
    - include: blockclose
    - include: type-case
  switch:
    - match: \b(SWITCH)\b
      scope: keyword.control.rl
      set: [switch-expression, control-label]
  switch-expression:
    - match: \(
      set: [switch-body, switch-after-expression, variable-or-expression]
  switch-after-expression:
    - match: \;
      scope: semi_colon.eol.ccpp
      set: [parenthese-close-pop, expression]
    - match: \)
      pop: true
  switch-body:
    - match: \{
      scope: open.curly.bracket.block.rl
      set: case
  case:
    - match: \b(DEFAULT)\b
      scope: keyword.control.rl
      set: [case-end, control-label]
    - match: (?=\S)
      set: [case-after-value, expression, control-label]
  case-after-value:
    - match: \,
      push: expression
    - include: case-end
  control-label:
    - match: "`.*?`"
      scope: comment control_label.rl
      pop: true
    - match: \[
      scope: comment
      set:
      - include: comments
      - match: \b([a-zA-Z_][a-zA-Z0-9_]*)\b|\".*?\"
        scope: comment
        set:
        - match: \]
          scope: comment control_label.rl
          pop: true
        - match: \S
          scope: invalid.illegal
      - match: \]
        scope: invalid.illegal
        pop: true
      - match: \S
        scope: invalid.illegal
    - match: (?=\S)
      pop: true
  case-end:
    - match: ':'
      scope: keyword.control.rl
      set: [after-case-stmt, statement]
    - match: \s+|\S
      scope: invalid.illegal
      pop: true
  after-case-stmt:
    - match: ->
      scope: keyword.control.rl
      set: case
    - include: blockclose
    - match: (?=\S)
      set: case
  break:
    - match: \b(BREAK)\b
      scope: keyword.control.rl
      set: [semicolon-close, control-label]
  continue:
    - match: \b(CONTINUE)\b
      scope: keyword.control.rl
      set: [semicolon-close, control-label]
  while:
    - match: \b(WHILE)\b
      scope: meta.while.rl keyword.control.rl
      set: [while-meta, while-after-label, control-label]
  while-after-label:
      - include: comments
      - match: \(
        set: [while-after-condition, variable-or-expression]
  while-meta:
    - meta_scope: meta.while.rl
    - match: ""
      pop: true
  while-after-condition:
    - include: comments
    - match: \)
      set: statement
  do-loop:
    - match: \b(DO)\b
      scope: keyword.control.rl
      set: [do-meta, do-condition, control-label]
  do-meta:
    - meta_scope: meta.do-loop.rl
    - match: ""
      pop: true
  do-condition:
    - match: \(
      set:
        - include: do-after-condition
        - match: (?=\S)
          set: [do-after-condition, variable-or-expression]
  do-after-condition:
    - match: \)
      set: [do-after-body, statement]
  do-after-body:
    - match: \b(FOR)\b
      scope: keyword.control.rl
      set:
      - match: \(
        set: for-condition
    - match: \b(WHILE)
      scope: keyword.control.rl
      set:
      - match: \(
        set: [parenthese-close-pop, expression]
  for:
    - match: \b(FOR)\b
      scope: keyword.control.rl
      set: [for-after-label, control-label]
  for-after-label:
      - match: \(
        set: [statement, for-condition, variable-or-expression-stmt-or-empty]
  for-condition:
    - match: (?=\;)
      set: [for-post-stmt, semicolon-close]
    - match: (?=\S)
      set: [for-post-stmt, expression-stmt]
  for-post-stmt:
    - include: parenthese-close-pop
    - match: (?=\S)
      set: [parenthese-close-pop, expression]
  parenthese-close-pop:
    - match: \)
      pop: true
  return:
    - match: =(?!=)
      scope: keyword.control.rl
      set: [semicolon-close, expression]
    - match: \b(RETURN)\b
      scope: keyword.control.rl
      set:
      - match: \;
        scope: semi_colon.eol.ccpp
        pop: true
      - match: (?=\S)
        set: [semicolon-close, expression]
  try:
    - match: \b(TRY)\b
      scope: keyword.control.rl
      set: [catch-or-finally, statement]
  catch-or-finally:
    - include: catch
    - include: finally
    - match: \S
      scope: invalid.illegal
  catch:
    - match: \b(CATCH)\b
      scope: keyword.control.rl
      set: catch-after-kw
  catch-after-kw:
    - include: comments
    - match: \(
      set:
      - include: catch-after-var
      - match: (?=\S)
        set: [catch-after-var, function-arg]
  catch-after-var:
    - include: comments
    - match: \)
      set: [after-catch-body, statement]
  finally:
    - include: comments
    - match: \b(FINALLY)\b
      scope: keyword.control.rl
      set: statement
  after-catch-body:
    - include: comments
    - include: catch
    - include: finally
    - match: (?=\S)
      pop: true
  assert:
    - match: \b(ASSERT)\b
      scope: keyword.control.rl
      set:
        - match: \(
          set: [semicolon-close, parenthese-close-pop, expression]
  comments:
    - match: ^\(/ =\s*(.*?)\s*= /\)$\n?
      scope: comment.block.c
      captures:
        1: meta.toc-list.banner.block.c
    - include: block-comment
    - include: line-comment
  block-comment:
    - match: \(//
      captures:
        0: punctuation.definition.comment.c comment.block.c
      push:
        - meta_scope: comment.block.c
        - match: /\)
          scope: comment.block.c 
          pop: true
        - match: (?=.)
          push:
          - meta_scope: string.quoted.double.rl
          - match: (?=/\))
            pop: true
          - include: block-comment
    - match: \(/
      captures:
        0: punctuation.definition.comment.c
      push:
        - meta_scope: comment.block.c
        - match: /\)
          pop: true
        - include: block-comment
    - match: /\).*$
      scope: invalid.illegal.stray-comment-end.c
  line-comment:
    - match: ///
      captures:
        0: punctuation.definition.comment.c
      push:
        - meta_scope: string.quoted.double.rl
        - match: $\n?
          pop: true
        - match: \\\s*$(\s|\S)
          push:
          - match: \s|\S
            pop: true
    - match: //
      captures:
        0: punctuation.definition.comment.c
      push:
        - meta_scope: comment.line.double-slash.c++
        - match: $\n?
          pop: true
        - match: \\\s*$(\s|\S)
          push:
          - match: \s|\S
            pop: true
